import { __toESM, require_core } from "../../core-Bd4l5kNc.js";

//#region src/utils/git/push-git.ts
var import_core = /* @__PURE__ */ __toESM(require_core(), 1);
/**
* Returns an async function to push changes to a specified branch in a GitHub repository using Octokit.
*
* @param octokit - An authenticated Octokit instance for GitHub API requests.
* @returns An async function that pushes changes to a branch.
*
* The returned function parameters:
* @param owner - The owner of the repository.
* @param repo - The name of the repository.
* @param branchName - The name of the branch to push changes to.
* @param commitMessage - (Optional) The commit SHA to update the branch reference to. Defaults to 'Update branch'.
* @returns The response data from the GitHub API after updating the reference, or undefined if an error occurs.
*
* @remarks
* The `commitMessage` parameter is used as the SHA for the updateRef call, which should be the commit SHA you want the branch to point to.
* If an error occurs during the push, the function will call `setFailed` with an appropriate error message.
*/
function gitPush(octokit) {
	return async function pushGit({ owner, repo, branchName, commitMessage = "Update branch" }) {
		try {
			const { data: pushData } = await octokit.rest.git.updateRef({
				owner,
				repo,
				ref: `heads/${branchName}`,
				sha: commitMessage,
				force: true
			});
			return pushData;
		} catch (error) {
			if (error instanceof Error) (0, import_core.setFailed)(`Failed to push git changes: ${error.message}`);
			else (0, import_core.setFailed)("Failed to push git changes: Unknown error");
		}
	};
}

//#endregion
export { gitPush };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVzaC1naXQuanMiLCJuYW1lcyI6WyJvY3Rva2l0OiBPY3Rva2l0Il0sInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3V0aWxzL2dpdC9wdXNoLWdpdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZXRGYWlsZWQgfSBmcm9tICdAYWN0aW9ucy9jb3JlJ1xuaW1wb3J0IHsgT2N0b2tpdCB9IGZyb20gJy4uLy4uL3R5cGVzL21vZGVscy9naXRodWIvb2N0b2tpdC5qcydcblxuZXhwb3J0IHR5cGUgR2l0UHVzaFBhcmFtcyA9IHtcbiAgb3duZXI6IHN0cmluZ1xuICByZXBvOiBzdHJpbmdcbiAgYnJhbmNoTmFtZTogc3RyaW5nXG4gIGNvbW1pdE1lc3NhZ2U/OiBzdHJpbmdcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIHB1c2ggY2hhbmdlcyB0byBhIHNwZWNpZmllZCBicmFuY2ggaW4gYSBHaXRIdWIgcmVwb3NpdG9yeSB1c2luZyBPY3Rva2l0LlxuICpcbiAqIEBwYXJhbSBvY3Rva2l0IC0gQW4gYXV0aGVudGljYXRlZCBPY3Rva2l0IGluc3RhbmNlIGZvciBHaXRIdWIgQVBJIHJlcXVlc3RzLlxuICogQHJldHVybnMgQW4gYXN5bmMgZnVuY3Rpb24gdGhhdCBwdXNoZXMgY2hhbmdlcyB0byBhIGJyYW5jaC5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gcGFyYW1ldGVyczpcbiAqIEBwYXJhbSBvd25lciAtIFRoZSBvd25lciBvZiB0aGUgcmVwb3NpdG9yeS5cbiAqIEBwYXJhbSByZXBvIC0gVGhlIG5hbWUgb2YgdGhlIHJlcG9zaXRvcnkuXG4gKiBAcGFyYW0gYnJhbmNoTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBicmFuY2ggdG8gcHVzaCBjaGFuZ2VzIHRvLlxuICogQHBhcmFtIGNvbW1pdE1lc3NhZ2UgLSAoT3B0aW9uYWwpIFRoZSBjb21taXQgU0hBIHRvIHVwZGF0ZSB0aGUgYnJhbmNoIHJlZmVyZW5jZSB0by4gRGVmYXVsdHMgdG8gJ1VwZGF0ZSBicmFuY2gnLlxuICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgR2l0SHViIEFQSSBhZnRlciB1cGRhdGluZyB0aGUgcmVmZXJlbmNlLCBvciB1bmRlZmluZWQgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgYGNvbW1pdE1lc3NhZ2VgIHBhcmFtZXRlciBpcyB1c2VkIGFzIHRoZSBTSEEgZm9yIHRoZSB1cGRhdGVSZWYgY2FsbCwgd2hpY2ggc2hvdWxkIGJlIHRoZSBjb21taXQgU0hBIHlvdSB3YW50IHRoZSBicmFuY2ggdG8gcG9pbnQgdG8uXG4gKiBJZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIHRoZSBwdXNoLCB0aGUgZnVuY3Rpb24gd2lsbCBjYWxsIGBzZXRGYWlsZWRgIHdpdGggYW4gYXBwcm9wcmlhdGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdpdFB1c2gob2N0b2tpdDogT2N0b2tpdCkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcHVzaEdpdCh7XG4gICAgb3duZXIsXG4gICAgcmVwbyxcbiAgICBicmFuY2hOYW1lLFxuICAgIGNvbW1pdE1lc3NhZ2UgPSAnVXBkYXRlIGJyYW5jaCcsXG4gIH06IEdpdFB1c2hQYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgLy8gUHVzaCB0aGUgY2hhbmdlcyB0byB0aGUgc3BlY2lmaWVkIGJyYW5jaFxuICAgICAgY29uc3QgeyBkYXRhOiBwdXNoRGF0YSB9ID0gYXdhaXQgb2N0b2tpdC5yZXN0LmdpdC51cGRhdGVSZWYoe1xuICAgICAgICBvd25lcixcbiAgICAgICAgcmVwbyxcbiAgICAgICAgcmVmOiBgaGVhZHMvJHticmFuY2hOYW1lfWAsXG4gICAgICAgIHNoYTogY29tbWl0TWVzc2FnZSwgLy8gVGhpcyBzaG91bGQgYmUgdGhlIFNIQSBvZiB0aGUgY29tbWl0IHlvdSB3YW50IHRvIHB1c2hcbiAgICAgICAgZm9yY2U6IHRydWUsIC8vIFVzZSBmb3JjZSBpZiBuZWNlc3NhcnlcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBwdXNoRGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBzZXRGYWlsZWQoYEZhaWxlZCB0byBwdXNoIGdpdCBjaGFuZ2VzOiAke2Vycm9yLm1lc3NhZ2V9YClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEZhaWxlZCgnRmFpbGVkIHRvIHB1c2ggZ2l0IGNoYW5nZXM6IFVua25vd24gZXJyb3InKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkEsU0FBZ0IsUUFBUUEsU0FBa0I7QUFDeEMsUUFBTyxlQUFlLFFBQVEsRUFDNUIsT0FDQSxNQUNBLFlBQ0EsZ0JBQWdCLGlCQUNGLEVBQUU7QUFDaEIsTUFBSTtHQUVGLE1BQU0sRUFBRSxNQUFNLFVBQVUsR0FBRyxNQUFNLFFBQVEsS0FBSyxJQUFJLFVBQVU7SUFDMUQ7SUFDQTtJQUNBLEtBQUssQ0FBQyxNQUFNLEVBQUUsWUFBWTtJQUMxQixLQUFLO0lBQ0wsT0FBTztHQUNSLEVBQUM7QUFFRixVQUFPO0VBQ1IsU0FBUSxPQUFPO0FBQ2QsT0FBSSxpQkFBaUIsa0NBQ1QsQ0FBQyw0QkFBNEIsRUFBRSxNQUFNLFNBQVMsQ0FBQzttQ0FFL0MsNENBQTRDO0VBRXpEO0NBQ0Y7QUFDRiJ9